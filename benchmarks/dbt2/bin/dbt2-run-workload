#!/bin/bash

#
# This file is released under the terms of the Artistic License.
# Please see the file LICENSE, included in this package, for details.
#
# Copyright (C) 2002-2006 Open Source Development Labs, Inc.
#               2002-2010 Mark Wong
#

self="$(basename "$0")"
self_dir="$(dirname "$0")"
bin_dir=`cd "${self_dir}"; pwd`
top_dir=`cd "${self_dir}"/..; pwd`
unset self_dir

trap 'echo "Test was interrupted by Control-C."; \
	killall dbt2-client dbt2-driver sar sadc vmstat iostat mpstat iopp; ${DB_COMMAND} dbt2-${DBMS}-stop-db; ${DB_COMMAND} killall dbt2-${DBMS}-db-stat sar sadc vmstat iostat mpstat iopp' INT
trap 'echo "Test was interrupted. Got TERM signal."; \
	killall dbt2-client dbt2-driver sar sadc vmstat iostat mpstat iopp; ${DB_COMMAND} dbt2-${DBMS}-stop-db; ${DB_COMMAND} killall dbt2-${DBMS}-db-stat sar sadc vmstat iostat mpstat iop' TERM

do_sleep()
{
	echo "Sleeping $1 seconds"
	sleep $1
}

make_directories()
{
	COMMAND=""
	HOST=${1}
	if [ -n "${HOST}" ]; then
		COMMAND="ssh ${HOST}"
	fi
	${COMMAND} mkdir -p ${OUTPUT_DIR}
	${COMMAND} mkdir -p ${CLIENT_OUTPUT_DIR}/`hostname`
	${COMMAND} mkdir -p ${DRIVER_OUTPUT_DIR}/`hostname`
	${COMMAND} mkdir -p ${DB_OUTPUT_DIR}
}

perf_stat_start()
{
	COMMAND=""
	DIR=${1}
	PERF_DIR=${1}/..
	HOST=${2}

	if [ -n "${HOST}" ]; then
		COMMAND="ssh ${HOST}"
	else
		HOST=`hostname`
	fi

	LC_NUMERIC=C perf stat --append -o $PERF_DIR/perf-stats.csv \
        -r 1 -e $COUNTERS -a -x "," -- sleep ${DURATION}
}

perf_record_start()
{
	COMMAND=""
	DIR=${1}
	HOST=${2}

	if [ -n "${HOST}" ]; then
		COMMAND="ssh ${HOST}"
	else
		HOST=`hostname`
	fi

	perf record -a -s -g -m 512 -- sleep ${DURATION}
}

usage()
{
	if [ "$1" != "" ]; then
		echo
		echo "error: $1"
	fi
	echo
	echo "usage: `basename $0` -h"
	echo "usage: `basename $0` -a <drizzle|mysql|nuodb|pgsql|sqlite>"
	echo "       -c <number of database connections>"
    echo "       -d <duration seconds>"
	echo "       -w <number of warehouses>"
    echo "       -o <path>"
    echo "       [options]"
	echo "options:"
	echo "       -H <database host name. (default localhost)>"
	echo "       -N <no database start/stop>"
	if [ "${DBMS}" = "drizzle" ]; then
		echo "       -i <drizzle working or installation directory>"
	fi
	echo "       -l <database port number>"
	echo "       -q <enable oprofile data collection>"
	echo "       -s <delay of starting of new threads in milliseconds>"
	echo "       -n <no thinking or keying time (default no)>"
	echo "       -D <database name>"
	if [ "${DBMS}" = "mysql" ]; then
		echo "       -u <database user>"
		echo "       -x <database password>"
	fi
	echo "       -z <comments for the test>"
	echo
	echo "Example: dbt2-run-workload -c 20 -d 100 -w 1"
	echo "Test will be run for 120 seconds with 20 database connections and"
	echo "scale factor (num of warehouses) 1."
	echo
}

validate_parameter()
{
	if [ "$2" != "$3" ]; then
		usage "wrong argument '$2' for parameter '-$1'"
		exit 1
	fi
}

DBNAME=dbt2
DB_HOSTNAME="localhost"
DB_PASSWORD=""
CLIENT_HOSTNAME="localhost"
WORKING_DIR=""

DB_USER=${DBUSER}
SLEEPY=1000 # milliseconds
USE_OPROFILE=0
USE_PERF_STAT=0
USE_PERF_RECORD=0
THREADS_PER_WAREHOUSE=10
USE_PGPOOL=0

while getopts "a:b:c:D:d:H:NS:hi:l:no:qS:s:t:u:w:x:z:p:r" opt; do
	case $opt in
	a)
		DBMS=${OPTARG}
		export DATABASE=${DBMS}
		;;
	b)
		# Number of warehouses per driver.
		W_CHUNK=${OPTARG}
		;;
	c)
		# Check for numeric value
		DBCON=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $DBCON
		;;
	D)
		DBNAME=${OPTARG}
		;;
	d)
		DURATION=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $DURATION
		;;
	H)
		DB_HOSTNAME=${OPTARG}
		;;

	N)
	    DB_MGMT_OFF=1
		;;
	h)
		usage
		exit 1
		;;
	i)
		# installation or working directory where drizzled and drizzle can be
		# found
		WORKING_DIR=${OPTARG}
		MISC_ARG="${MISC_ARG} -w ${WORKING_DIR}"
		;;
	l)
		DB_PORT=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $DB_PORT
		;;
	n)
		NO_THINK="-ktd 0 -ktn 0 -kto 0 -ktp 0 -kts 0 -ttd 0 -ttn 0 -tto 0 -ttp 0 -tts 0"
		;;
	o)
		OUTPUT_DIR=${OPTARG}
		;;
	q)
		USE_OPROFILE=1
		;;
	S)
		SOCK_FILE=${OPTARG}
		SOCK_FILE_ARG="-t ${OPTARG}"
		;;
	s)
		SLEEPY=`echo ${OPTARG} | egrep "^[0-9]+$"`
		validate_parameter ${opt} ${OPTARG} ${SLEEPY}
		;;
	t)
		THREADS_PER_WAREHOUSE=`echo ${OPTARG} | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $THREADS_PER_WAREHOUSE
		;;
	u)
		DB_USER=${OPTARG}
		;;
	w)
		WAREHOUSES=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $WAREHOUSES
		;;
	x)
		DB_PASSWORD=${OPTARG}
		;;
	z)
		COMMENT=$OPTARG
		;;
        p)
                USE_PERF_STAT=1
                COUNTERS=${OPTARG}
                ;;
        r)
                USE_PERF_RECORD=1
                ;;
	esac
done


# If no chunking of warehouses per process is defined, assumed we want to run
# everything from one process.
if [ "x${W_CHUNK}" = "x" ]; then
	W_CHUNK=${WAREHOUSES}
fi

# Check parameters.

if [ "x${DBMS}" = "x" ]; then
	echo "specify which dbms system to test using -a <drizzle|mysql|pgsql|sqlite>"
	exit 1
fi

if [ "x${DBCON}" = "x" ]; then
	echo "specify the number of database connections using -c #"
	exit 1
fi

if [ "x${DURATION}" = "x" ]; then
	echo "specify the duration of the test in seconds using -d #"
	exit 1
fi

if [ "x${WAREHOUSES}" = "x" ]; then
	echo "specify the number of warehouses using -w #"
	exit 1
fi

if [ "x${OUTPUT_DIR}" = "x" ]; then
	echo "specify the location for results, directory must not exist, using -o <path>"
	exit 1
fi

if [ -d "${OUTPUT_DIR}" ]; then
	echo "directory '${OUTPUT_DIR}' exists, stopping to prevent possible"
	echo "clobbering of data, please specify another -o location"
	exit 1
fi

if [ ${THREADS_PER_WAREHOUSE} -lt 1 ] || [ ${THREADS_PER_WAREHOUSE} -gt 1000 ];
then
	usage "-t value should be in range [1..1000]. Please specify correct value"
	exit 1
fi

if [ ! "x${DB_PORT}" = "x" ]; then
	DB_PORT_ARG="-l ${DB_PORT}"

	# Drizzle specific handling of passing around non-standard port.
	if [ "x${DBMS}" = "xdrizzle" ]; then
		MISC_ARG="${MISC_ARG} ${DB_PORT_ARG}"
	fi
fi

ULIMIT_N=`ulimit -n`
ESTIMATED_ULIMIT=`expr 2 \* ${WAREHOUSES}`
ESTIMATED_ULIMIT=`expr ${ESTIMATED_ULIMIT} \* ${THREADS_PER_WAREHOUSE}`
ESTIMATED_ULIMIT=`expr ${ESTIMATED_ULIMIT} + ${DBCON}`
if [ ${ULIMIT_N} -lt ${ESTIMATED_ULIMIT} ]; then
	usage "you're open files ulimit is too small, must be at least ${ESTIMATED_ULIMIT}"
	exit 1
fi

CLIENT_OUTPUT_DIR=${OUTPUT_DIR}/client
DRIVER_OUTPUT_DIR=${OUTPUT_DIR}/driver
DB_OUTPUT_DIR=${OUTPUT_DIR}/db

REPORT_FILE="${OUTPUT_DIR}/report.txt"

#
# Create the directories we will need.
#
make_directories

# Create a readme file in the output directory and date it.
date >> ${OUTPUT_DIR}/readme.txt
echo "$COMMENT" >> ${OUTPUT_DIR}/readme.txt
uname -a >> ${OUTPUT_DIR}/readme.txt
echo "Command line: $0 $@" >> ${OUTPUT_DIR}/readme.txt

# Output run information into the readme.txt.
echo "Database Scale Factor: $WAREHOUSES warehouses" >> ${OUTPUT_DIR}/readme.txt
echo "Test Duration: $DURATION seconds" >> ${OUTPUT_DIR}/readme.txt
echo "Database Connections: $DBCON" >> ${OUTPUT_DIR}/readme.txt

#
# Redisplay the test parameters.
#
echo "DBT-2 test for ${DBMS} started..."
echo ""
echo "DATABASE SYSTEM: ${DB_HOSTNAME}"
if [ "${DBMS}" = "pgsql" ] || [ "${DBMS}" = "mysql" ] || [ "${DBMS}" = "drizzle" ] || [ "${DBMS}" = "nuodb" ]; then
	echo "DATABASE NAME: ${DBNAME}"
fi

#
# Build up the client command line arguments.
#

if [ -n "${DB_USER}" ]; then
	echo "DATABASE USER: ${DB_USER}"
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -u ${DB_USER}"
fi

if [ -n "${DB_PASSWORD}" ]; then
	echo "DATABASE PASSWORD: *******"
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -a ${DB_PASSWORD}"
fi

if [ -n "${DB_SOCKET}" ]; then
	echo "DATABASE SOCKET: ${DB_SOCKET}"
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -t ${DB_SOCKET}"
fi

if [ -n "${DB_PORT}" ]; then
	echo "DATABASE PORT: ${DB_PORT}"
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} ${DB_PORT_ARG}"
fi

THREADS=`expr ${WAREHOUSES} \* ${THREADS_PER_WAREHOUSE}`
echo "DATABASE CONNECTIONS: ${DBCON}"
echo "TERMINAL THREADS: ${THREADS}"
echo "TERMINALS PER WAREHOUSE: ${THREADS_PER_WAREHOUSE}"
echo "WAREHOUSES PER THREAD/CLIENT PAIR: ${W_CHUNK}"
echo "SCALE FACTOR (WAREHOUSES): ${WAREHOUSES}"
echo "DURATION OF TEST (in sec): ${DURATION}"
echo "1 client stared every ${SLEEPY} millisecond(s)"
echo ""

#
# Start the client.
#
echo "Stage 1. Starting up client..."
if [ ${DBMS} = "pgsql" ]; then
	if [ ${USE_PGPOOL} -eq 1 ]; then
		echo "Starting pgpool..."
		pgpool -f ${DIR}/pgsql/pgpool.conf
		TMP_DB_HOSTNAME="localhost"
	else
		TMP_DB_HOSTNAME=${DB_HOSTNAME}
	fi
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -d ${TMP_DB_HOSTNAME}"
fi
CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -f -c ${DBCON} -s ${SLEEPY}"
END=0
START=1
#
# Count of the number of clients run.
#
SEG=0
PORT=30000
while [ ${END} -lt ${WAREHOUSES} ]; do
	START=`expr ${END} + 1`
	END=`expr ${START} + ${W_CHUNK}`
	END=`expr ${END} - 1`
	SEG=`expr ${SEG} + 1`

	if [ ${END} -gt ${WAREHOUSES} ]; then
		END=${WAREHOUSES}
	fi

	CDIR="${CLIENT_OUTPUT_DIR}/`hostname`.${SEG}"
	mkdir -p ${CDIR}
	$bin_dir/dbt2-client ${CLIENT_COMMAND_ARGS} -p ${PORT} -o ${CDIR} > \
			${CLIENT_OUTPUT_DIR}/`hostname`/client-${SEG}.out 2>&1 || exit 1 &
	PORT=`expr ${PORT} + 1`
done

# Sleep long enough for all the client database connections to be established.
SLEEPYTIME=${DBCON}
SLEEPYTIME=`expr ${SLEEPYTIME} \* ${SLEEPY}`
SLEEPYTIME=`expr ${SLEEPYTIME} / 1000`
SLEEPYTIME=`expr ${SLEEPYTIME} + 1`
do_sleep ${SLEEPYTIME}

# Start collecting data before we start the test.
SLEEP_RAMPUP=`expr ${W_CHUNK} + 1`
SLEEP_RAMPUP=`expr ${SLEEP_RAMPUP} \* 10`
SLEEP_RAMPUP=`expr ${SLEEP_RAMPUP} \* ${SLEEPY}`
SLEEP_RAMPUP=`expr ${SLEEP_RAMPUP} / 1000`

# Start the driver.
echo ''
echo "Stage 2. Starting up driver..."
echo "${SLEEPY} threads started per millisecond"

END=0
START=1
#
# Count of the number of drivers run.
#
SEG=0
PORT=30000
while [ ${END} -lt ${WAREHOUSES} ]; do
	START=`expr ${END} + 1`
	END=`expr ${START} + ${W_CHUNK}`
	END=`expr ${END} - 1`
	SEG=`expr ${SEG} + 1`

	if [ ${END} -gt ${WAREHOUSES} ]; then
		END=${WAREHOUSES}
	fi

	DDIR="${DRIVER_OUTPUT_DIR}/`hostname`.${SEG}"
	mkdir -p ${DDIR}
	DRIVER_COMMAND_ARGS="-d ${CLIENT_HOSTNAME} -p ${PORT} -l ${DURATION} -wmin ${START} -wmax ${END} -w ${WAREHOUSES} -sleep ${SLEEPY} -outdir ${DDIR} -tpw ${THREADS_PER_WAREHOUSE} ${NO_THINK}"
	PORT=`expr ${PORT} + 1`
	$bin_dir/dbt2-driver ${DRIVER_COMMAND_ARGS} > \
			${DRIVER_OUTPUT_DIR}/`hostname`/driver-${SEG}.out 2>&1 || exit 1&
done

echo -n "estimated rampup time: "
do_sleep $SLEEP_RAMPUP
echo "estimated rampup time has elapsed"

# Start perf stat
if [ ${USE_PERF_STAT} -eq 1 ]; then
	perf_stat_start ${OUTPUT_DIR} &
	if [ -n ${DB_HOSTNAME} ] && [ ! "x${DB_HOSTNAME}" = "xlocalhost" ]; then
		perf_stat_start ${DB_OUTPUT_DIR} ${DB_HOSTNAME} &
	fi
fi

# Start perf record
if [ ${USE_PERF_RECORD} -eq 1 ]; then
	perf_record_start ${OUTPUT_DIR} &
	if [ -n ${DB_HOSTNAME} ] && [ ! "x${DB_HOSTNAME}" = "xlocalhost" ]; then
		perf_record_start ${DB_OUTPUT_DIR} ${DB_HOSTNAME} &
	fi
fi

# Sleep for the duration of the run.
echo -n "estimated steady state time: "
do_sleep $DURATION

echo ''
echo "Stage 3. Processing of results..."

# Client doesn't go away by itself like the driver does, so kill it.
echo "Killing client..."
killall dbt2-client dbt2-driver 2> /dev/null

#if [ ! ${DB_MGMT_OFF} ]; then

	#if [ "x${DB_COMMAND}" = "x" ]; then
		#dbt2-${DBMS}-stop-db ${MISC_ARG}
	#else
		#${DB_COMMAND} "dbt2-${DBMS}-stop-db ${MISC_ARG}"
	#fi
	#if [ ${DBMS} = "pgsql" ]; then
		#if [ ${USE_PGPOOL} -eq 1 ]; then
			#pgpool -f ${DIR}/pgsql/pgpool.conf stop
		#fi
	#fi
#fi

# Run some post processing analysese.
MIXAGG="${OUTPUT_DIR}/mix.log"
# Aggregate all the mix.log file from all possible driver processes into a
# single location to be ananlyzed.
find ${DRIVER_OUTPUT_DIR} -name mix.log | xargs cat | \
		sort -t ',' -k 1 > ${MIXAGG}
$bin_dir/dbt2-post-process ${MIXAGG} > ${REPORT_FILE}

# Change the permissions on the database error log, not readable by other
# users by default.
if [ -f "${DB_OUTPUT_DIR}/log" ]; then
	chmod 644 ${DB_OUTPUT_DIR}/log
fi

echo "Test completed."
echo "Results are in: ${OUTPUT_DIR}"
echo

cat ${REPORT_FILE}
